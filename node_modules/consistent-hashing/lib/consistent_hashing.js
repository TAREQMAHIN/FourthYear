var crypto = require('crypto');


var ConsistentHashing = function(nodes, options) {
  /**
   * NOTE : Doesn't change value of number of replicas
   * 
   * Having more than one instance of a node would create problem 
   * to 3 node archtecture as left and right nodes would be different
   * for different instance
   */
  this.replicas  = 1;
  this.algorithm = 'md5'
  // stores mapping from keys to node
  this.ring  = {};
  // stores the keys attached to node
  this.keys  = [];
  // stores all node
  this.nodes = [];

  if (options && options.replicas)  this.replicas  = options.replicas;
  if (options && options.algorithm) this.algorithm = options.algorithm;

  for (var i = 0; i < nodes.length; i++) {
    this.addNode(nodes[i]);
  }
};


ConsistentHashing.prototype.getNodeOrder = function() {
  return this.nodes;
};


// function to add a node from universal hashing structure
ConsistentHashing.prototype.addNode = function(node) {
  this.nodes.push(node);

  for (var i = 0; i < this.replicas; i++) {
    var key = this.crypto((node.id || node) + ':' + i);

    this.keys.push(key);
    this.ring[key] = node;
  }

  this.keys.sort();
};


// function to remove a node from universal hashing structure
ConsistentHashing.prototype.removeNode = function(node) {
  for (var i = 0; i < this.nodes.length; i++) {
    if (this.nodes[i] == node) {
      this.nodes.splice(i, 1);
      i--;
    }
  }

  for (var i = 0; i < this.replicas; i++) {
    var key = this.crypto((node.id || node) + ':' + i);
    delete this.ring[key];

    for (var j = 0; j < this.keys.length; j++) {
      if (this.keys[j] == key) {
        this.keys.splice(j, 1);
        j--;
      }
    }
  }
};


// returns the node on which query should be processed
ConsistentHashing.prototype.getNode = function(key) {
  // console.log(this.ring);
  // console.log(this.keys);
  // console.log(this.nodes);
  if (this.getRingLength() == 0) return 0;

  var hash = this.crypto(key);
  var pos  = this.getNodePosition(hash);

  return this.ring[this.keys[pos]];
};

// returns the node on left side of node in universal hashing structure
ConsistentHashing.prototype.getLeftNode = function(node) {
  if (this.getRingLength() == 0) return 0;
  var key = this.crypto((node.id || node) + ':' + 0);
  var pos  = this.getNodePosition(key);
  if(pos == 0) pos = this.getRingLength() - 1;
  else pos = pos - 1;
  return this.ring[this.keys[pos]];
};

// returns the node on right side of node in universal hashing structure
ConsistentHashing.prototype.getRightNode = function(node) {
  if (this.getRingLength() == 0) return 0;
  var key = this.crypto((node.id || node) + ':' + 0);
  var pos  = this.getNodePosition(key);
  if(pos == this.getRingLength() - 1) pos = 0;
  else pos = pos + 1;
  return this.ring[this.keys[pos]];
};


ConsistentHashing.prototype.getNodePosition = function(hash) {
  var upper = this.getRingLength() - 1;
  var lower = 0;
  var idx   = 0;
  var comp  = 0;

  if (upper == 0) return 0;

  while (lower <= upper) {
    idx  = Math.floor((lower + upper) / 2);
    comp = this.compare(this.keys[idx], hash);

    if (comp == 0) {
      return idx;
    } else if (comp > 0) {
      upper = idx - 1;
    } else {
      lower = idx + 1;
    }
  }

  if (upper < 0) {
    upper = this.getRingLength() - 1;
  }

  return upper;
};


ConsistentHashing.prototype.getRingLength = function() {
  return Object.keys(this.ring).length;
};


ConsistentHashing.prototype.compare = function(v1, v2) {
  return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
};


ConsistentHashing.prototype.crypto = function(str) {
  return crypto.createHash(this.algorithm).update(str).digest('hex');
};


module.exports = ConsistentHashing;
